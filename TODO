    Old code and TODO
    
    
    
    
    Old Code
    
    /****** this code was the precursor to a functioning friends request/add functionality
    
    
    //
    // if chat is on pending list
    
    
    // if chat is on confirmed list
    
    
    
//    if (friendsalready) {
//        // friends
//        if (chatexists) {
//            // friends and chat exists. Send chat message to database
//            
//            // add chat to users active chats.
//        } else {
//            // friends but start new chatlog
//            // when other user logs in it will get all 
//            
//            // add chat to users active chats.
//        }
//    } else {
//        // not friends 
//        if (chatexists) {
//            // not friends but chatlog exists. 
//            if (onconfirmedlist) {
//                // send chat
//                // add chat to users active chats.
//            } else if (onpendinglist) {
//                // accept request to chat
//                // take off pending list and put into confirmed in chat
//                // send chat
//                // add chat to users active chats.
//            } else {
//                res.json({querystatus: 'you are not apart of this chat'});
//            }
//        } else {
//            // not friends & no chatlog 
//            var chatData = {
//                host: req.body.username,
//                users: [
//                    {
//                        confirmed: [
//                            req.body.username
//                    ]
//                    },
//                    {
//                        pending: [
//                            req.body.chatwith
//                        ]
//                    },
//                ],
//                log: [
//                    {
//                        host: req.body.username,
//                        content: 'this is a chat',
//                        timestamp: new Date().toLocaleString(),
//                    },
//                ]
//            };
//
//            // use schema's 'create' method to insert document into Mongo
//            Chat.create(chatData, function (error, chat) {
//                if (error) {
//                    console.log('error creating new chat');
//                    return next(error);
//                } else {
//                    return res.json(chat);
//                }
//            });
//            
//            // add chat to users active chats.
//            // put chat id into other users pending chats list.
//            
//        }
//    }


// old login function

//router.post('/login', (req, res, next) => {
//    console.log(req.body.email);
//    if (req.body.email && req.body.password) {
//        User.authenticate(req.body.email, req.body.password, function (error, user) {
//            console.log(user);
//            if (error || !user) {
//                var err = new Error('Wrong email or password');
//                err.status = 401;
//                err.type = "login error";
//                return next(err);
//            } else {
//                req.session.userId = user._id;
//                req.session.username = user.username;
//                let options = {
//                    maxAge: 1000 * 60 * 60 * 24 * 7, // 1 week
//                    signed: true,
//                }
//                if (req.cookies.loggedIn === undefined) {
//                    (res.cookie('loggedIn', user.username, [options]));
//                }
//                return res.json({querystatus: "loggedin"});
//            }
//        });
//    } else {
//        var err = new Error('Email and password are required');
//        err.status = 401;
//        err.type = "login error";
//        return next(err);
//    }
//});

// old implementation of queue BAD

// SEARCH / GET USERS THAT MATCH THIS QUERY.
// router.post('/searchusers', (req, res, next) => {
//   return searchusersf(req, res, next);
//    let request = JSON.parse(stringify(req, null));
//    let job = reqQueue.add({
//        request: request,
//    });
//    reqQueue.process(function(job, done) {
//        console.log(job.data);
//        return searchusersf(job.data.request, res, next);
//        done();
//        // this.on('completed', job => job.remove());
//        throw new Error('some unexpected error');
//        next();
//    });
//    
//    reqQueue.on('completed', (job, result) => {
//        console.log(`Job completed with result ${result}`);
//    });
});

// socket interval

// Ends last interval from old method instance and starts a new one
//if (interval) {
//clearInterval(interval);
//}
//let intervalVal = (15000);
//interval = setInterval(() => getApiAndEmit(socket), intervalVal); // Creates interval after being destroyed

// check matching room
result.forEach((roomAssign, index) => {
                    if (room == roomAssign) {
                        console.log("room match");
                    }
                });
                
                //            let awaitJoin = new Promise((resolve, reject) => {
//                resolve(socket.join(room));
//            });
            
//            let getRoomData = function(room) {
//                awaitRoom(room).then(function(data) {
//                    return data;
//                })
//            };
//            
//            let awaitRoom = async function(room) {
//                try {
//                    await socket.join(room);
//                } catch(err) {
//                    throw new Error();
//                }
//            }
//           
//            let awaitRooms = async function() {
//                let array = [] = await function() {
//                    for (let i = 0; i < result.length; i++) {
//                        console.log(result[i]);
//                        val = awaitRoom(result[i]);
//                    }
//                }
//            }
//            
//            let getData = async () => {
//                return Promise.all(result.map(room => getRoomData(room)));
//            }
////            const getData = async () => {
////                return Promise.all(result.map(room => awaitRoom(room)));
////            }
//            
////            awaitRooms().then(function() {
////                console.log(socket.rooms);
////            });
//            console.log(socket.rooms);
//            getData().then(function(data) {
//                setTimeout(function() {
//                    console.log(socket.rooms);
//                }, 500);
//            });



//const getApiAndEmit = async socket => {
//        let ts = Date.now();
//        let date_ob = new Date(ts); let date = date_ob.getDate(); let month = date_ob.getMonth() + 1; let year = date_ob.getFullYear(); let hour = date_ob.getHours(); let minute = date_ob.getMinutes(); let seconds = date_ob.getSeconds();
//        let am = (hour => 12) ? "pm" : "am";
        // prints date & time in YYYY-MM-DD format
//        socket.emit("FromAPI", "Socket io Time: " + year + "-" + month + "-" + date + " | " + (hour % 12) + ":" + minute + ":" + seconds + " " + am); // Emitting a new message. It will be consumed by the client
//    }

// Redis and bull functionality to queue all incoming requests
// Example redis request
//redisclient.set('foo', 'bar', redis.print);
//redisclient.get('foo', function (error, result) {
//    if (error) {
//        console.log(error);
//        throw error;
//    }
//    console.log('GET result ->' + result);
//});
//redisclient.del('foo');
//redisclient.get('foo', redis.print);

//Basic bull queue. Should queue all queries except queries to main page. Necessary for basic performance with large set of users.

let reqQueue = new Queue('request'); // Bull basic request queue.

// All requests could be given basic urgency and be treated the same. Instructions for request would be determined by req.originalUrl . Header info would be put into data and then parsed when taken from binary redis database. Each request must be refactored as a stand alone function that can be called within a job call e.g.

// 1. queue is created above. like let queue = new Queue('videoQueue');
// 2. Create data in form of array. like let data = { reqUrl: req.originalUrl, otherstuff: stuff }
// 3. Do queue.add(data, options)
// 4. reqQueue.process(async job => {
//      await RouteFunction(job.data);
//    })


//router.use(function(req, res, next) {
//    // Can create a new queue with Bull. Determine if earlier jobs are running. If not, then next(), else wait.
//
//    console.log("-Redis, bull request req.originalUrl: " + req.originalUrl); // Log url user queried
//    let data = {
//        reqUrl: req.originalUrl
//    }
//
//    let options = {
//        attempts: 2
//    }
//
//    reqQueue.add(data, options); // Add job with data and options to queue.
//    next(); // sends to next
//});


// basic Consumer that begins doing the job using specific function.
//reqQueue.process(async job => {
//        await dofunction(job.data);
//})

// basic Listener.
//myFirstQueue.on('completed', (job, result) => {
//  console.log(`Job completed with result ${result}`);
//})